
R version 3.4.4 (2018-03-15) -- "Someone to Lean On"
Copyright (C) 2018 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> args = commandArgs(trailingOnly=TRUE)
> 
> libraries = c("dplyr","magrittr","tidyr","readxl","nimble","HDInterval")
> for(x in libraries) { library(x,character.only=TRUE,warn.conflicts=FALSE) }
nimble version 0.6-12 is loaded.
For more information on NIMBLE and a User Manual,
please visit http://R-nimble.org.
> 
> '%&%' = function(x,y)paste0(x,y)
> 
> rho = 0.19
> 
> # 1. Incubation period
> 
> ## Data
> #### excluding index case
> onsetTimes = c(17, 19, 21, 21, 21, 22, 22, 23, 23, 23, 23, 23, 25, 26, 26, 26, 27, 31, 39, 41, 41, 42, 44)
> deathTimes = c(33, 48, 31, 47, 30, 41, 37, 32, 31, 35, 54, 30, 31, 33, 30, 33, 48, 39, 51, 48, 55, 60, 62)
> ## Prior knowledge
> exposureTimesLower = c(5,  9,  5,  9,  5,  5,  5,  11, 5,  5,  13, 11, 12, 5,  11, 11, 5,  5,  12, 25, 5,  25, 25)
> exposureTimesUpper = c(15, 18, 18, 15, 18, 18, 18, 15, 18, 18, 14, 15, 18, 18, 15, 15, 18, 18, 18, 31, 18, 31, 31)
> 
> ## Initialization
> nimIncubationData = list(
+     onsetTime = onsetTimes,
+     deathTime = deathTimes,
+     exposureTimeLower = exposureTimesLower,
+     exposureTimeUpper = exposureTimesUpper
+ )
> nimIncubationConsts = list(
+     nCases = length(onsetTimes),
+     incubation_uncertainty = 0.5,
+     death_uncertainty = 0.5
+ )
> nimIncubationInits = list(
+     incubation_mean = mean(onsetTimes-.5*(exposureTimesLower+exposureTimesUpper)),
+     incubation_var = var(onsetTimes-.5*(exposureTimesLower+exposureTimesUpper)),
+     death_mean = mean(deathTimes-onsetTimes),
+     death_var = var(deathTimes-onsetTimes),
+     exposureTime = .5*(exposureTimesLower+exposureTimesUpper),
+     exposure_mu = .5*(exposureTimesLower+exposureTimesUpper),
+     exposure_sigma = (exposureTimesUpper-exposureTimesLower)/1.96/2,
+     incubationTime = onsetTimes-.5*(exposureTimesLower+exposureTimesUpper),
+     timeToDeath = deathTimes-onsetTimes
+ )
> ## Main script
> nimIncubationCode = nimbleCode({
+     # priors for parameters of incubation period
+     incubation_mean ~ dinvgamma(0.001, 0.001)
+     incubation_var ~ dinvgamma(0.001, 0.001)
+     death_mean ~ dinvgamma(0.001, 0.001)
+     death_var ~ dinvgamma(0.001, 0.001)
+     # priors for known time of exposure
+     exposure_mu[1:nCases] <- (exposureTimeLower[1:nCases]+exposureTimeUpper[1:nCases])/2
+     exposure_sigma[1:nCases] <- (exposureTimeUpper[1:nCases]-exposureTimeLower[1:nCases])/1.96/2
+     for (k in 1:nCases) {
+         exposureTime[k] ~ dnorm(exposure_mu[k],sd=exposure_sigma[k])
+         incubationTime[k] ~ dgamma(shape=incubation_mean^2/incubation_var,rate=incubation_mean/incubation_var)
+         timeToDeath[k] ~ dgamma(shape=death_mean^2/death_var,rate=death_mean/death_var)
+         onsetTime[k] ~ dnorm(exposureTime[k] + incubationTime[k], sd=incubation_uncertainty)
+         deathTime[k] ~ dnorm(exposureTime[k] + incubationTime[k] + timeToDeath[k], sd=death_uncertainty)
+     }
+ })
> ## Nimble Model
> nimIncubationModel = nimbleModel(nimIncubationCode,
+                         data = nimIncubationData,
+                         constants = nimIncubationConsts,
+                         inits = nimIncubationInits)
defining model...
building model...
setting data and initial values...
running calculate on model (any error reports that follow may simply reflect missing values in model variables) ... 
checking model sizes and dimensions...
model building finished.
> 
> nimIncubationConf = configureMCMC(nimIncubationModel,
+                                   monitors=c("incubation_mean","incubation_var"),
+                                   monitors2=c("death_mean","death_var"),
+                                   monitors3=nimIncubationSamples %>% select(contains("exposure")) %>% colnames,
+                                   thin = 30, thin2 = 10, thin3 = 5)
> nimIncubationConf$addSampler(target = c("incubation_mean","incubation_var","death_mean","death_var"),
+                              type = "RW_block", control = list(adaptInterval = 100))
Note: Assigning an RW_block sampler to nodes with very different scales can result in low MCMC efficiency.  If all nodes assigned to RW_block are not on a similar scale, we recommend providing an informed value for the "propCov" control list argument, or using the AFSS sampler instead.
> 
> 
> ## Model compilation
> nimIncubationMCMC = buildMCMC(nimIncubationConf)
> compiledIncubationModel = compileNimble(nimIncubationModel,nimIncubationMCMC)
compiling... this may take a minute. Use 'showCompilerOutput = TRUE' to see C++ compiler details.
compilation finished.
> 
> set.seed(0) #for reproducibility
> Niter = 14e4
> Nburn = 2e4
> compiledIncubationModel$nimIncubationMCMC$run(niter=Niter,nburn=Nburn)
|-------------|-------------|-------------|-------------|
|-------------------------------------------------------|
NULL
> compiledIncubationModel$nimIncubationMCMC$mvSamples %>% as.matrix %>% as.data.frame -> nimIncubationSamples
> compiledIncubationModel$nimIncubationMCMC$mvSamples2 %>% as.matrix %>% as.data.frame -> nimIncubationSamples2
> 
> ## Credible intervals
> IncubationCIs = hdi(nimIncubationSamples,.95) %>% as.data.frame %>% { tibble::rownames_to_column(.,"var") }
> 
> nimIncubationSamples %>%
+     summarise_all(funs(mean)) %>%
+     mutate(var="median") %>%
+     rbind(IncubationCIs) %>%
+     select(var,everything()) -> IncubationCIs
> 
> (IncubationCIs)
     var incubation_mean incubation_var
1 median        12.80086      21.940173
2  lower        10.59472       5.834861
3  upper        14.96593      41.020733
> 
> ## Credible intervals
> IncubationCIs2 = hdi(nimIncubationSamples2,.95) %>% as.data.frame %>% { tibble::rownames_to_column(.,"var") }
> 
> nimIncubationSamples2 %>%
+     summarise_all(funs(mean)) %>%
+     mutate(var="median") %>%
+     rbind(IncubationCIs2) %>%
+     select(var,everything()) -> IncubationCIs2
> 
> IncubationCIs %<>% left_join(IncubationCIs2)
Joining, by = "var"
> 
> IncubationCIs %>%
+     filter(var=="median") %>%
+     select(-var) -> mediansJos
> 
> # Incubation period = gamma distribution
> message("incubation_mean")
incubation_mean
> mediansJos$incubation_mean
[1] 12.80086
> message("incubation_var")
incubation_var
> mediansJos$incubation_var
[1] 21.94017
> 
> incubation_shape = mediansJos$incubation_mean^2/mediansJos$incubation_var
> incubation_rate = mediansJos$incubation_mean/mediansJos$incubation_var*7.0 #from days to weeks
> message("incubation shape and scale")
incubation shape and scale
> print(c(incubation_shape,1/incubation_rate))
[1] 7.4685845 0.2448515
> 
> # Time from Onset to Death
> message("period_to_death_mean")
period_to_death_mean
> mediansJos$death_mean
[1] 13.77073
> message("period_to_death_var")
period_to_death_var
> mediansJos$death_var
[1] 60.04276
> death_shape = mediansJos$death_mean^2/mediansJos$death_var
> death_rate = mediansJos$death_mean/mediansJos$death_var*7.0 #from days to weeks
> message("period_to_death shape and scale")
period_to_death shape and scale
> print(c(death_shape,1/death_rate))
[1] 3.158297 0.622882
> 
> # 2. Analyzing the main dataset
> 
> yearMin = 2016
> 
> data = read_excel("../../data/Nigeria_raw.xlsx", sheet = "Incidence") %>%
+     select(-one_of("Timeseries","Imputation","File in the repo"),-contains("URL")) %>%
+     filter(Year>=yearMin) %>%
+     group_by(Year) %>%
+     mutate(Incidence_Reported = if_else(Week==1,Reported,Reported-lead(Reported)),
+            Incidence_Deaths = if_else(Week==1,Deaths,Deaths-lead(Deaths))
+           ) %>%
+     ungroup
> 
> data %>% select(Year,Week,starts_with("Incidence")) -> Df
> 
> Df %>% head
# A tibble: 6 x 4
   Year  Week Incidence_Reported Incidence_Deaths
  <dbl> <dbl>              <dbl>            <dbl>
1  2018    30                 16                0
2  2018    29                 33                3
3  2018    28                 15                1
4  2018    27                 20                2
5  2018    26                 12                0
6  2018    25                 24                2
> 
> data.frame(Year=yearMin-1,Week=1:52,Incidence_Reported=NA,Incidence_Deaths=NA) %>%
+     rbind(Df %>% arrange(Year,Week)) %>%
+     rowwise %>%
+     mutate(Incidence_Reported_NA=ifelse(is.na(Incidence_Reported),rpois(1,30),NA),
+            Incidence_Deaths_NA=ifelse(is.na(Incidence_Deaths),rpois(1,1),NA)) %>%
+     ungroup -> Df
> 
> K = nrow(Df)
> 
> # Convolutions
> incubation_probability = pgamma(1:K,shape=incubation_shape,rate=incubation_rate)-pgamma(1:K-1,shape=incubation_shape,rate=incubation_rate)
> timeFromOnsetToDeath_probability = pgamma(1:K,shape=death_shape,rate=death_rate)-pgamma(1:K-1,shape=death_shape,rate=death_rate)
> # time from Exposure event to Death is the convolution of two latter probabilities
> timeFromExposureToDeath_probability = c(0)
> for (x in 2:K) {
+     timeFromExposureToDeath_probability = c(timeFromExposureToDeath_probability,
+         sum(incubation_probability[1:(x-1)]*timeFromOnsetToDeath_probability[(x-1):1]))
+ }
> 
> recalc = F
> 
> shift = 26
> 
> K = nrow(Df)
> 
> nimData = list(infected = Df$Incidence_Reported,
+                dead = Df$Incidence_Deaths)
> 
> nimConsts = list(r = rho,
+                  K = K,
+                  week = (Df$Week-shift-1)%%52+1,
+                  incubationPeriod = incubation_probability[1:K],
+                  periodToDeath = timeFromExposureToDeath_probability[1:K])
> 
> nimInits = function(){
+     list(l1 = (44-shift-1)%%52+1,
+          l2 = (8-shift-1)%%52+1,
+          infected = Df$Incidence_Reported_NA,
+          dead = Df$Incidence_Deaths_NA,
+          lambdaIncidence = rep(0,K),
+          lambdaDeath = rep(0,K),
+          exposure = rgamma(K,10,1),
+          CFR = rgamma(K,0.08,1),
+          alpha_a = c(rgamma(1,25,1),rgamma(1,5,1)),
+          beta_a = rgamma(2,1,1),
+          alpha_q = rgamma(1,1,1),
+          beta_q = rgamma(1,1,1))}
> 
> nimConvolution = nimbleFunction(
+     run = function(a = double(1), b = double(1)) {
+         L <- dim(a)[1]
+         ans <- inprod(a[L+1-1:L],b)
+         return(ans)
+         returnType(double(0))
+     }
+ )
> 
> nimCode = nimbleCode({
+     ## exposure and awareness
+     for (k in 1:K) {
+         af[k] <- equals(step(week[k]-l1),step(l2-week[k]))+1
+         exposure[k] ~ dgamma(alpha_a[af[k]],beta_a[af[k]])
+         CFR[k] ~ dgamma(alpha_q,beta_q)
+     }
+     ### I start from week 53 because the first 52 weeks were added with missing data
+     ### in order to avoid edge effects for the convolution
+     for (k in 52:(K-1)) {
+         lambdaIncidence[k+1] <- nimConvolution(exposure[1:k],incubationPeriod[1:k])/(1-r)
+         lambdaDeath[k+1] <- CFR[k+1]*nimConvolution(exposure[1:k],periodToDeath[1:k])/(1-r)
+         infected[k+1] ~ dpois(lambdaIncidence[k+1])
+         dead[k+1] ~ dpois(lambdaDeath[k+1])
+     }
+     ## Priors
+     for(i in 1:2) {
+         alpha_a[i] ~ dexp(1)
+         beta_a[i] ~ dinvgamma(0.001, 0.001)
+     }
+     alpha_q ~ dexp(1)
+     beta_q ~ dinvgamma(0.001, 0.001)
+     l1 ~ dunif(0,50)
+     l2 ~ dunif(l1+2,53)
+ })
> 
> nimModel = nimbleModel(nimCode,
+                        constants = nimConsts,
+                        data = nimData,
+                        inits = nimInits())
defining model...
Adding incubationPeriod,periodToDeath as data for building model.
building model...
setting data and initial values...
running calculate on model (any error reports that follow may simply reflect missing values in model variables) ... 
checking model sizes and dimensions...
model building finished.
> 
> # see https://r-nimble.org/better-block-sampling-in-mcmc-with-the-automated-factor-slice-sampler
> nimConf = configureMCMC(nimModel,setSeed=TRUE)
> nimConf$addMonitors(c('l2'))
thin = 1: alpha_a, beta_a, alpha_q, beta_q, l1, l2
> 
> nimConf$removeSamplers(c('alpha_a[1]', 'beta_a[1]'))
> nimConf$addSampler(target = c('alpha_a[1]', 'beta_a[1]'), type = 'AF_slice')
> nimConf$removeSamplers(c('alpha_a[2]', 'beta_a[2]'))
> nimConf$addSampler(target = c('alpha_a[2]', 'beta_a[2]'), type = 'AF_slice')
> nimConf$removeSamplers(c('alpha_q', 'beta_q'))
> nimConf$addSampler(target = c('alpha_q', 'beta_q'), type = 'AF_slice')
> nimConf$removeSamplers(c('l1', 'l2'))
> nimConf$addSampler(target = c('l1', 'l2'), type = 'AF_slice')
> # thinning parameter
> nimConf$setThin(200)
thin = 200: alpha_a, beta_a, alpha_q, beta_q, l1, l2
> ## Checking that all variables are properly initialized
> nimModel$initializeInfo()
All model variables are initialized.
> 
> ## Model compilation
> nimMCMC = buildMCMC(nimConf)
> compiledModel = compileNimble(nimModel,nimMCMC)
compiling... this may take a minute. Use 'showCompilerOutput = TRUE' to see C++ compiler details.
compilation finished.
> 
> Niter = 4e5
> Nburn = 2e3
> set.seed(as.numeric(args[1]))
> compiledModel$nimMCMC$run(niter=Niter+Nburn, nburnin = Nburn)
|-------------|-------------|-------------|-------------|
|-------------------------------------------------------|
NULL
> compiledModel$nimMCMC$mvSamples %>% as.matrix %>% as.data.frame -> nimSamples
> 
> saveRDS(nimSamples, file = paste0("nimSamples-",args[1],".rds"))
> 
> proc.time()
     user    system   elapsed 
14142.045    15.249 14145.984 
